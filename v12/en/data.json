{
    "version": "0.1",
    "pageContent": 
	{
        "_comments": "object that contains data for page labels, buttons, etc.",
        "navItems": 
		{
            "_common": 
			{
                "buttonBackToGallery": 
				{
                    "name": "Back To Gallery",
					"method": "backToGallery()",
					"idName": "backToGallery"	
                },
                "buttonStartTutorial": 
				{
                    "name": "Start Tutorial",
					"method": "startTutorialFromDetailsScreen()",
					"idName": "startTutorial"
                },
				"buttonViewDetails": 
				{
                    "name": "View Details",
					"method": "viewDetails()",
					"idName": "stepsViewDetails"	
                }
            }
        }
    },
    "tutorial": 
	{
        "_common": 
		{
            "name": "Using MQ and HTTP to link message flows in a coordinated request-reply scenario",
            "shortDescription": "Learn how to use an MQ queue to store messages which link together HTTP request and reply flows with a back end application",
            "durationText": "This tutorial takes approximately",
            "durationTime": "15 minutes",
            "_resourceToOpenComment": "The ID of the first resource to open when the user imports the tutorial. Resource IDs are defined in the repo_metadata.json Tutorials listing on ot4i.",
            "resourceToOpen": "MainFlow",
            "helpLink": 
			{
                "text": "IBM Knowledge Center",
           		"link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.ace.home.doc/help_home.htm"
            }
        },
        "pageDetails": 
		{
            "topicsName": "Tutorial topics",
            "_topicListComment": "A short list of product concepts or tasks demonstrated by this tutorial",
            "topicList": 
			[
                {
                    "title": "HTTPInput node"
                },
				{
                    "title": "HTTPReply node"
                },
				{
                    "title": "MQGet node"
                }
            ],
            "outcomesName": "Learning outcomes",
            "_outcomesComment": "A description of what the user will have learned or accomplished by running this tutorial.",
            "outcomeList": 
			[
                {
                    "title": "Use IBM App Connect Enterprise to link together HTTP clients with a back-end application using MQ queues defined on a local queue manager."
                }
            ],
            "summary": 
			{
                "overviewName": "OVERVIEW",
                "_overviewComment": "A short description of what happens in this tutorial, and an optional short explanation of the concepts used in this tutorial if necessary for context. What background knowledge must the user have for this to make sense?",
                "sections": 
				[
                    {
                        "section": "This tutorial demonstrates a simple architectural pattern for coordinating HTTP request and reply messages when exchanging information with a back-end application via MQ queues.  There are three message flows - a RequestFlow, a BackendApplicationFlow and a ReplyFlow. RequestFlow receives JSON data over HTTP, and stores the initial input data on a queue, before passing part of the data on to the BackendApplicationFlow using an MQ queue. The MQ message is written using the HTTP Reply Identifier as the MsgId value. When the BackendReplyApp responds, it follows the very common MQ Request-Reply convention of copying this identifier into the CorrelId of the MQ reply message. This means that the final ReplyFlow can recover the stored initial input data and unify part of this data with the repsonse from the backend and return it to the initial requesting HTTP client."
			       },
					{
						"section":"To simulate how a similar pattern might apply to real world scenarios, RequestFlow and ReplyFlow also execute simple message transformation from JSON to XML and vice versa. In this example, BackendApplicationFlow represents some kind of voting application. Personal information like a voter's name and address is held by the RequestFlow and ReplyFlow but is not passed to the BackendApplicationFlow."						
					},
                    {
                        "section": "The tutorial instructions are structured for an integration node owned server, that is associated with a local queue manager, but could be easily amended to run in an independent integration server if you prefer.There are no other pre-requisites needed by the scenario."
                    }
                ]
            },
			"helpLinks": 
			{
				"_helpLinksComment": "Helplinks that have a type:web attribute are rendered as web links. Otherwise, links are assumed to be to embedded Help topics in the Knowledge Center.",
				"title": "Find out more",
				"details": 
				[
					{
						"title": "Knowledge Center link to ",
						"description": "Developing integration solutions by using applications",
						"link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.etools.mft.doc/bi12002_.htm",
						"type": "web"
					}
				]
			}
        },
        "pageSteps": 
		{
            "create": 
			{
                "overview": 
				{
                    "name": "Create",
                    "heading": "Import projects",
                    "_createComment": "A description of what will happen when the user clicks Import.",
                    "sections": 
					[
                        {
                            "section": "When you click Import, a single project will be created in your workspace: An application named <span class='application'>CoordinatedRequestReplyTutorial</span>. The application contains three message flows: <span class='application'>RequestFlow</span>, <span class='application'>BackendApplicationFlow</span> and <span class='application'>ReplyFlow</span>."
                        },
                        {
                            "section": "<span class='application'>RequestFlow</span> receives a JSON input message over HTTP. The subflow named <span class='application'>StoreOriginalMessage</span> converts from HTTP to MQ and stores a copy of the input data on a queue named <b>STORE.QUEUE</b>. The following Compute node transforms into an XML output message and writes to BACKEND.QUEUE."
						},
						{
							"section": "<span class='application'>BackendApplicationFlow</span> receives the XML message and stores the voting intention (A or B!) in an in-memory variable. The output message is given a field to represent the time at which the data was processed by carrying the current time value. The MQReply node at the end of the flow writes the message to the queue BACKEND.REPLY"
						},
						{
							"section": "<span class='application'>ReplyFlow</span> parses the XML reply message, and uses its CorrelId to retrieve the original input message stored on <b>STORE.QUEUE</b> using an MQGet node, and combines the name of the voter with the ProcessingTime value that was returned by the back-end.  The reply message is returned back to the original requesting client over HTTP."
						},
                        {
			    			"section": "Once imported using the link on the right, the application <span class='application'>CoordinatedRequestReplyTutorial</span> is ready to be deployed and tested. Before doing this, we will configure an integration node using the instructions on the Prepare tab."
						}
                    ]
                },
                "helpLinks": 
				{
                    "title": "Find out more",
                    "details": 
					[
                        {
                            "title": "Knowledge Center link to ",
                            "description": "Developing integration solutions by using applications",
                            "link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.etools.mft.doc/bi12002_.htm",
							"type": "web"
                        }
                    ]
                },
                "actions": 
				{
                    "title": "Create Actions",
                    "details": 
					[
                        {
                            "name": "Import",
                            "method": "importArtifacts()"
                        }
                    ]
                }
            },
            "prepare": 
			{
                "overview": 
				{
                    "name": "Prepare",
                    "heading": "Create a queue manager and integration node, and then deploy the message flows",
                    "_prepareComment": "A description of what just happened when the user clicked Import, and what will happen when the user clicks Deploy.",
                    "sections": 
		     [
			 {
                     "section":"The tutorial requires MQ definitions for three queues.  Execute the following steps to prepare your environment accordingly:",
                     "steps":{
                        "type":"ordered",
                        "details":[
                           	{
                              "details":"Create an IBM MQ queue manager and configure it by completing the following steps:",
                              "substeps":{
                                 "type":"ordered",
                                 "details":[
                                    {
                                       "details":"Open the IBM App Connect Enterprise Console. If you don't already have one, create and start a queue manager:<br><code><span class='cmdname'>crtmqm</span> <span class='varname'>TESTQM</span></code><br><code><span class='cmdname'>strmqm</span> <span class='varname'>TESTQM</span></code>"
                                    },
                                    {
                                       "details":"Next create the two queues by typing the following commands:<br><code>runmqsc <span class='varname'>TESTQM</span></code><br><code>define ql(BACKEND.QUEUE)</code><br><code>define ql(BACKEND.REPLY)</code><br><code>define ql(STORE.QUEUE)</code>"
                                    }									
                                 ]
                              }
                           },                           
                           {
                              "details":"Create an integration node which is associated with the above queue manager by completing the following steps:",
                              "substeps":{
                                 "type":"ordered",
                                 "details":[
                                    {
                                       "details":"In the console window, create an integration node by typing the following command:<br><code><span class='cmdname'>mqsicreatebroker</span> <span class='varname'>TESTNODE</span> -q <span class='varname'>TESTQM</span></code>"
                                    },
									{
                                       "details":"Start the integration node by typing the following command:<br><code><span class='cmdname'>mqsistart</span> <span class='varname'>TESTNODE</span></code>"
                                    },
                                    {
                                       "details":"Create an integration server associated with the integration node by typing the following command:<br><code><span class='cmdname'>mqsicreateexecutiongroup</span> <span class='varname'>TESTNODE</span> -e <span class='varname'>default</span></code>"
                                    }
                                 ]
                              }
                           },
						   {
						   		"details":"Back in the Toolkit, drag and drop deploy the provided BAR file named <span class='application'>CoordinatedRequestReplyTutorial.bar</span> which you will find inside the <span class='application'>CoordinatedRequestReplyTutorial</span> application."
                    		}							
                        ]
                     }
                  }
             ]
                },
                "helpLinks": 
				{
                }
            },
            "run": 
			{
                "overview": 
				{
                    "name": "Run",
                    "heading": "",
                    "_runComment": "The full steps for the user to run through the tutorial. Use 'sections' to render paragraphs, 'steps' with a type of 'ordered' or 'unordered' to render HTML lists, and 'substeps' to render nested lists.",
                "sections":[                            
                            {
                                "section": "<h4>Use the Flow Exerciser to test the tutorial scenario",
                                "steps": {
                                    "type": "ordered",
                                    "details": [                                      
                                    {
                                        "details": "Open <span class='application'>RequestFlow.msgflow</span>.",
                                        "substeps":{
                                        "type": "unordered",
                                        "details": 
								        [
                                        {
                                          "details": "Click the Flow Exerciser icon <img src='http://ot4i.github.io/ot4i.tutorials//dist/images/icons/iib/startFlowExerciser.png' alt='' /> to start testing the flow (when challenged you do not need to redeploy the flow again)."
                                        },
										{										
										"details":"Click the Send Message icon <img src='http://ot4i.github.io/iib-tutorials/images/icons/iib/sendMessage.png' alt='' /> to select a message to send to the flow. Choose <b>VoteA</b>. The message data looks like this:<br><br><code>{<br>&nbsp;&nbsp;\"VoterName\": \"Joe Bloggs\",<br>&nbsp;\"VoterAddress\":\"Hursley Park Southampton SO21 2JN\",<br>&nbsp;\"VotingIntention\": \"A\"<br>}<br></code>"
										},
										{										
										"details":"The HTTP Reply message will look like this:<br><code>{<br>&nbsp;&nbsp;\"Reply\": \"Thank you Joe Bloggs for voting. Your intention has been successfully registered! It was processed at 20:38:32\"<br>}<br></code>. This scenario needs no further MQ output, so you can safely ignore the Listening for response status message and just click Close."
										}									
                                        ]
                                        }
                                    }
                                ]
                            }
                        },
			{
			    "section": "This tutorial has shown how to use an MQ queue to store messages which link together HTTP request and reply flows with a back end application."			
			}
                    ]
                },
                "helpLinks": 
				{
                    "title": "Find out more",
                    "details": 
					[
 						{
                            "title": "Knowledge Center link to ",
                            "description": "HTTPInput node",
                            "link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.etools.mft.doc/ac04560_.htm",
							"type": "web"
                        },
 						{
                            "title": "Knowledge Center link to ",
                            "description": "HTTPReply node",
                            "link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.etools.mft.doc/ac04585_.htm",
							"type": "web"
                        },
						 						{
                            "title": "Knowledge Center link to ",
                            "description": "MQGet node",
                            "link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.etools.mft.doc/ac20806_.htm",
							"type": "web"
                        },						
						{
                            "title": "Knowledge Center link to ",
                            "description": "Testing your message flow by using the Flow exerciser",
                            "link": "https://www.ibm.com/support/knowledgecenter/en/SSTTDS_11.0.0/com.ibm.etools.mft.doc/rt26110_.htm",
							"type": "web"
                        }
                    ]
                }
            }
        }
    }
}